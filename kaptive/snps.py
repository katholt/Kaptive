"""
Copyright 2023 Tom Stanton (tomdstanton@gmail.com)
https://github.com/tomdstanton/kaptive-mapper

This file is part of kaptive-mapper. kaptive-mapper is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by the Free Software Foundation,
either version 3 of the License, or (at your option) any later version. kaptive-mapper is distributed
in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
details. You should have received a copy of the GNU General Public License along with kaptive-mapper.
If not, see <https://www.gnu.org/licenses/>.
"""
import subprocess
from pathlib import Path
from tempfile import NamedTemporaryFile

from kaptive.log import warning, quit_with_error


class VcfRecord:
    def __init__(self, line):
        line = line.split('\t')
        if len(line) < 8:
            raise ValueError(f"VCF line does not have enough columns: {line}")
        self.chrom = line[0]
        self.pos = int(line[1])
        self.id = line[2]
        self.ref = line[3]
        self.alt = line[4]
        self.qual = line[5]
        self.filter = line[6]
        self.info = line[7].split(";")
        self.format = line[8] if len(line) > 8 else None
        self.samples = line[9:] if len(line) > 9 else None

        self.dna_pos = f"{self.pos}{self.ref}>{self.alt}"
        # Parse BCSQ info and extract consequence, gene name, gene id, biotype, strand, aa_pos
        bcsq = None
        for i in self.info:
            if i.startswith("BCSQ="):
                if len(x := i.lstrip("BCSQ=").split("|")) == 7:
                    bcsq = x

        self.consequence = bcsq[0] if bcsq else None
        self.gene_name = bcsq[1] if bcsq else None
        self.gene_id = bcsq[2].rstrip(".t1") if bcsq else None
        self.biotype = bcsq[3] if bcsq else 'intergenic'
        self.strand = bcsq[4] if bcsq else None
        self.aa_pos = bcsq[5] if bcsq else None

    def __repr__(self):
        return f"{self.chrom} {self.dna_pos}"

    def __str__(self):
        return self.__repr__()

    def __eq__(self, other):
        return self.chrom == other.chrom and self.dna_pos == other.dna_pos

    def get_vcf_line(self):
        return f"{self.chrom}\t{self.pos}\t{self.id}\t{self.ref}\t{self.alt}\t{self.qual}\t{self.filter}\t" \
               f"{self.info}\t{self.format}\t{self.samples}\n"


def get_mutation(snps: list[VcfRecord], synonymous: bool = False, all_mutations: bool = False, delim: str = ";") -> str:
    """
    Gets the first disruptive mutation from a list of SNPs generated by `bcftools csq`
    (https://samtools.github.io/bcftools/bcftools.html#csq)
    - Expects the SNPs to belong to the same gene
    - Expects the SNPs to be sorted by position
    - Possible mutations are:
        3_prime_utr, 5_prime_utr, coding_sequence, feature_elongation, frameshift, inframe_altering,
        inframe_deletion, inframe_insertion, intergenic, intron, missense, non_coding, splice_acceptor, splice_donor,
        splice_region, start_lost, start_retained, stop_gained, stop_lost, stop_retained, synonymous
    - We don't care about the following mutations:
        3_prime_utr, 5_prime_utr, coding_sequence, feature_elongation, intergenic, intron, , non_coding,
        splice_acceptor, splice_donor, splice_region, , start_retained, stop_gained, stop_lost, stop_retained,
    """
    if not snps:
        return ''
    mutations = []
    consequences = [
        'frameshift', 'inframe_altering', 'inframe_deletion', 'inframe_insertion', 'missense', 'start_lost',
        'start_retained', 'stop_gained', 'stop_lost', 'stop_retained'
    ]
    if synonymous:
        consequences.append('synonymous')
    if snps:
        mutations += [f'{snp.consequence}({snp.aa_pos})' for snp in snps if snp.consequence in consequences]
    if mutations:
        return delim.join(mutations) if all_mutations else mutations[0]
    else:
        return ''


def snp_calling_pipeline(reference_fasta: Path, sam: Path, gff: Path, threads: int = 1, min_depth: int = 10,
                         min_qual: int = 40, min_mq: int = 60, phase: str = 'm', targets: List[str] = None):
    """
    The pipeline was inspired by Torsten Seemann's blog post:
    https://thegenomefactory.blogspot.com/2018/10/a-unix-one-liner-to-call-bacterial.html

    Assumes mapping reads to locus has been run:
     minimap2 -ax sr locus_refs.fna sample_{1,2}.fastq.gz > sample.sam
    """
    # Define commands
    targets_string = f"--targets {','.join(targets)}" if targets else ""
    sort_cmd = f"samtools sort -l 0 --threads {threads} {sam}".split()  # -l 0 = uncompressed
    mpileup_cmd = f"bcftools mpileup {targets_string} --threads {threads} --min-MQ {min_mq} -Ou -B -f {reference_fasta} -".split()
    call_cmd = f"bcftools call --threads {threads} --ploidy 1 -Ou -v -m -".split()
    norm_cmd = f"bcftools norm --threads {threads} -Ou -f {reference_fasta} -d all -".split()
    filter_cmd = f"""bcftools_filter_--threads_{threads}_-Ou_-e_'QUAL<{min_qual} || DP<{min_depth} || GT!="1/1"'""".split("_")
    csq_cmd = f"bcftools csq --threads {threads} --phase {phase} -f {reference_fasta} -g {gff}".split()
    # Run commands
    sort_proc = subprocess.Popen(sort_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    mpileup_proc = subprocess.Popen(mpileup_cmd, stdin=sort_proc.stdout, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    sort_proc.stdout.close()  # Allow sort_proc to receive a SIGPIPE if mpileup_proc exits.

    call_proc = subprocess.Popen(call_cmd, stdin=mpileup_proc.stdout, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    mpileup_proc.stdout.close()  # Allow mpileup_proc to receive a SIGPIPE if call_proc exits.

    norm_proc = subprocess.Popen(norm_cmd, stdin=call_proc.stdout, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    call_proc.stdout.close()  # Allow call_proc to receive a SIGPIPE if norm_proc exits.

    filter_proc = subprocess.Popen(filter_cmd, stdin=norm_proc.stdout, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    norm_proc.stdout.close()  # Allow norm_proc to receive a SIGPIPE if filter_proc exits.

    csq_proc = subprocess.Popen(csq_cmd, stdin=filter_proc.stdout, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    filter_proc.stdout.close()  # Allow filter_proc to receive a SIGPIPE if csq_proc exits.

    out, err = csq_proc.communicate()
    if not out:
        if err:
            warning(err.decode())
        return ''
    else:
        return out.decode()


def vcf2consensus(vcf: str, reference_fasta: str):
    """
    Convert a VCF file to a consensus sequence using bcftools consensus
    """
    with NamedTemporaryFile(mode='w', suffix='.vcf.gz') as tmp:
        vcf_index = Path(tmp.name).with_suffix('.gz.csi')
        # Define commands
        bgzip_cmd = f"bcftools view -Oz -o {tmp.name}".split()
        tabix_cmd = f"bcftools index {tmp.name}".split()
        cons_cmd = f"bcftools consensus {tmp.name}".split()
        # Run commands
        bgzip_proc = subprocess.Popen(bgzip_cmd, stdin=subprocess.PIPE, stderr=subprocess.PIPE)
        _, err = bgzip_proc.communicate(input=vcf.encode())
        if err:
            warning(err.decode())
        if Path(tmp.name).stat().st_size == 0:
            quit_with_error("VCF file is empty")
        tabix_proc = subprocess.Popen(tabix_cmd, stderr=subprocess.PIPE)
        _, err = tabix_proc.communicate()
        if err:
            warning(err.decode())
        if not vcf_index.exists():
            quit_with_error(f"Failed create VCF index file: {vcf_index}")
        cons_proc = subprocess.Popen(cons_cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = cons_proc.communicate(input=reference_fasta.encode())
        vcf_index.unlink()
        if not out:
            if err:
                warning(err.decode())
            return ''
        else:
            return out.decode()
